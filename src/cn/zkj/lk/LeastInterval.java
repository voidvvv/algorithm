package cn.zkj.lk;

/*
* 给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。

然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的最短时间。

示例 1：

输入: tasks = ["A","A","A","B","B","B"], n = 2
输出: 8
执行顺序: A -> B -> (待命) -> A -> B -> (待命) -> A -> B.
注：

任务的总个数为 [1, 10000]。
n 的取值范围为 [0, 100]。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/task-scheduler
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/


import java.util.Arrays;

public class LeastInterval {
    public int leastInterval(char[] tasks, int n) {
        /*
        * 根据题目，我们可以想到的是，先取出数量最多的那种任务来完成，这样才能让所需时间尽可能短
        * 由于所有任务都有一个冷却时间n，我们可以采用n+1个任务执行为一轮的方式来计算时间
        * eg：   冷却时间为3，那么第一个任务执行后需要等3次执行时间 第一次（执行） 第二次（冷却1） 第三次（冷却2） 第四次（冷却3）第五次（执行）
        *
        * */

        //因为任务是从A到Z，最多26种，所以为了给这些任务赋值数量，就创建一个长度为26的数组
        int [] map = new int[26];
        //遍历给出的字节数组tasks
        for (char c :tasks){
            //在这里，我们用遍历出来的字节与字节A相减作为该字符的下标。 即，从A到Z，在我们自己创建的数组中表示为0-25
            //并且每当遍历到一个字节，就把我们创建的数组中相应位置的数值+1
            map[c-'A']++;
        }
        //给map数组排序
        Arrays.sort(map);
        //排序后从小到大 这样，我们就把所有的任务按照数量给排序了，并且
//        先将时间设置出来，初始值为0
        int time =0;
        //然后开始按照 n+1次为一轮来执行任务
        //首先要保证我们创建的map集合最后一位大于零（任务次数最多的任务应该有执行次数）
        while (map[25]>0){
            //开始执行n+1次为一轮的任务，用i来表示任务执行的次数
            int i =0;
            while (i<=n){
                //这里break是跳出每一轮的小循环，是为了最后再执行一次排序。以防25之前还有任务有剩余次数
                if (map[25]==0){
                    break;
                }
                //当指针i小于26时，并且当前位置的执行次数大于0时，让此处的任务数量减一
                if (i < 26 && map[25 - i] > 0) {
                    map[25 - i]--;
                }
                //循环执行到这里，不论是否有任务执行，或是全部冷却，时间均++，指针也++
                time++;
                i++;
            }
            //每当一个小循环完毕时，就将剩下的任务再次按照数量来排序，以便开始下次循环
            Arrays.sort(map);
        }
        return time;
    }
}
